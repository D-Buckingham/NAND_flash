
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/param.h>

#include <stdlib.h>
#include <string.h>
#include <zephyr/device.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <assert.h>

#include    "test_spi_nand_top_layer.h"
#include    "spi_nand_oper_tests.h"
#include    "nand_top_layer.h"





LOG_MODULE_REGISTER(test_spi_nand_top_layer, CONFIG_LOG_DEFAULT_LEVEL);


#define PATTERN_SEED    0x12345678


//put the spi_handle into the spi_nand_flash_device_t struct and initialize the device
void setup_nand_flash(spi_nand_flash_device_t **out_handle, const struct spi_dt_spec *spi_handle)
{

    spi_nand_flash_config_t nand_flash_config = {
        .spi_dev = spi_handle,
    };

    spi_nand_flash_device_t *device_handle = NULL;

    int ret = spi_nand_flash_init_device(&nand_flash_config, &device_handle);//TODO correctly handled? &
    if(ret != 0){
        LOG_ERR("Initialization of device on top layer, error: %d", ret);
    }else{
        LOG_INF("device on top layer initialized");
    }
    *out_handle = device_handle;
}



int wait_and_chill(const struct spi_dt_spec *dev){
    uint8_t status;
    int ret = 0;
    while (true) {
        ret = spi_nand_read_register(dev, REG_STATUS, &status);
        if (ret != 0) {
            LOG_ERR("Error reading NAND status register while waiting");
            ret = -1;
        }

        if ((status & STAT_BUSY) == 0) {
            break;
        }
        k_sleep(K_MSEC(1)); 
    }
    return ret;
}


int test1_setup_erase_deinit_top_layer(const struct spi_dt_spec *spi)
{
    spi_nand_flash_device_t *nand_flash_device_handle = NULL;
    setup_nand_flash(&nand_flash_device_handle, spi);
    int err;
    err = spi_nand_erase_chip(nand_flash_device_handle);
    if(err != 0){
        LOG_ERR("Erase chip of device on top layer, error: %d", err);
        return -1;
    }

    err = spi_nand_flash_deinit_device(nand_flash_device_handle);
    if(err != 0){
        LOG_ERR("Deinitialize device on top layer, error: %d", err);
        return -1;
    }
    LOG_INF("Test 1 DHARA top layer: setup, erase, deinit successful!");
    return 0;
    
}


/**
 * The check_buffer function is validating that each uint32_t sized segment of the buffer src matches a series 
 * of expected values generated by rand(), starting with a seed, to ensure the buffer's content integrity or 
 * correct data handling, particularly useful for debugging or testing memory operations where data consistency is crucial.
*/

int check_buffer(uint32_t seed, const uint8_t *src, size_t count)
{
    int ret = 0;
    srand(seed);
    for (size_t i = 0; i < count; ++i) {
        uint8_t val = src[i];
        uint8_t expected = rand() & 0xFF; 
        if (val != expected) {
            if(i == 600){
            LOG_ERR("Mismatch at index %zu: expected 0x%02X, got 0x%02X", i, expected, val);
            }ret = -1;
        }
    }
    return ret;
}

void fill_buffer(uint32_t seed, uint8_t *dst, size_t count){
    srand(seed);
    for (size_t i = 0; i < count; ++i) {
        dst[i] = rand() & 0xFF;  
        //LOG_INF("Index %zu: 0x%02X", i, dst[i]);
    }
}



int do_single_write_test(spi_nand_flash_device_t *flash, uint32_t start_sec, uint16_t sec_count)
{
    static uint8_t pattern_buf[2048];
    static uint8_t temp_buf[2048];
    uint32_t sector_size, sector_num;

    memset((void *)pattern_buf, 0x00, sizeof(pattern_buf));
    memset((void *)temp_buf, 0x00, sizeof(temp_buf));


    int ret = spi_nand_flash_get_capacity(flash, &sector_num);
    if(ret != 0){
        LOG_ERR("Unable to retrieve flash capacity, error: %d", ret);
        return -1;
    }

    ret = spi_nand_flash_get_sector_size(flash, &sector_size);
    if(ret != 0){
        LOG_ERR("Unable to get sector size, error: %d", ret);
        return -1;
    }

    if ((start_sec + sec_count) > sector_num) {
        LOG_ERR("Sector range exceeds flash size.");
        return -1;
    }

    
    fill_buffer(PATTERN_SEED, pattern_buf, sector_size);


    for (int i = start_sec; i < sec_count; i++) { 
        
        if(spi_nand_flash_write_sector(flash, pattern_buf, i) != 0){
            LOG_ERR("Failed to write sector at index %d", i);
            return -1;
        }

        memset((void *)temp_buf, 0x00, sector_size);
        ret = wait_and_chill(flash -> config.spi_dev);
        
        
        
        if(spi_nand_flash_read_sector(flash, temp_buf, i) != 0){
            LOG_ERR("Failed to read sector at index %d", i);
            return -1;
        }
       
        
        check_buffer(PATTERN_SEED, temp_buf, sector_size);
    }
    return 0;
}

int test2_writing_tests_top_layer(const struct spi_dt_spec *spi)
{
    
    uint32_t sector_num, sector_size;
    spi_nand_flash_device_t *nand_flash_device_handle;
    setup_nand_flash(&nand_flash_device_handle, spi);

    if(spi_nand_flash_get_capacity(nand_flash_device_handle, &sector_num) != 0){
        LOG_ERR("Unable to retrieve flash capacity");
        return -1;
    }
    if(spi_nand_flash_get_sector_size(nand_flash_device_handle, &sector_size) != 0){
        LOG_ERR("Unable to get sector size");
        return -1;
    }
    printf("Number of sectors: %d, Sector size: %d\n", sector_num, sector_size);

    LOG_INF("Test2, Setup complete");
    
    if(do_single_write_test(nand_flash_device_handle, 1, 16)!= 0){
        LOG_ERR("fails first single write test");
    }else{
        LOG_INF("single write read test 1 successful");
    }

    if (do_single_write_test(nand_flash_device_handle, 16, 32) != 0) {
        LOG_ERR("Failed second single write test");
    }else{
        LOG_INF("single write read test 2 successful");
    }

    if (do_single_write_test(nand_flash_device_handle, 32, 64) != 0) {
        LOG_ERR("Failed third single write test");
    }else{
        LOG_INF("single write read test 3 successful");
    }

    if (do_single_write_test(nand_flash_device_handle, 64, 128) != 0) {
        LOG_ERR("Failed fourth single write test");
    }else{
        LOG_INF("single write read test 4 successful");
    }

    if (do_single_write_test(nand_flash_device_handle, sector_num / 2, 32) != 0) {
        LOG_ERR("Failed fifth single write test at middle of the flash");
    }else{
        LOG_INF("single write read test 5 successful");
    }

    if (do_single_write_test(nand_flash_device_handle, sector_num / 2, 256) != 0) {
        LOG_ERR("Failed sixth single write test at middle with larger span");
    }else{
        LOG_INF("single write read test 6 successful");
    }

    if (do_single_write_test(nand_flash_device_handle, sector_num - 20, 16) != 0) {
        LOG_ERR("Failed last single write test near the end of the flash");
    }else{
        LOG_INF("single write read test 7 successful");
    }

    if(spi_nand_flash_deinit_device(nand_flash_device_handle) != 0){
        LOG_ERR("Deinitialize device on top layer");
        return -1;
    }else{
        LOG_INF("Properly deinitialized top layer DHARA");
    }
    LOG_INF("SUCCESS!!! Write read tests dhara top layer");
    return 0;
}



int test_struct_handling(const struct spi_dt_spec *spi){
    static uint8_t pattern_buf[2048];
    static uint8_t temp_buf[2048];
    spi_nand_flash_device_t *flash;
    setup_nand_flash(&flash, spi);

    uint32_t sector_size, sector_num;
    memset((void *)pattern_buf, 0x00, sizeof(pattern_buf));
    memset((void *)temp_buf, 0x00, sizeof(temp_buf));

    int ret = spi_nand_flash_get_capacity(flash, &sector_num);
    if(ret != 0){
        LOG_ERR("Unable to retrieve flash capacity, error: %d", ret);
        return -1;
    }

    ret = spi_nand_flash_get_sector_size(flash, &sector_size);
    if(ret != 0){
        LOG_ERR("Unable to get sector size, error: %d", ret);
        return -1;
    }

    LOG_INF("Test 3: testing SPI NAND sector write and read register");
    
 
    fill_buffer(PATTERN_SEED, pattern_buf, sector_size);//we store every 4 byte address 4 bytes//(uint8_t*) pattern_buf??


    if(spi_nand_flash_write_sector(flash, pattern_buf, 2) != 0){
        LOG_ERR("Failed to write sector at index %d", 1);
        return -1;
    }
    

    ret = wait_and_chill(flash -> config.spi_dev);
    if (ret != 0) {
        return -1;
    }

    if(spi_nand_flash_read_sector(flash, temp_buf, 2) != 0){
            LOG_ERR("Failed to read sector at index %d", 1);
            return -1;
        }


    ret = check_buffer(PATTERN_SEED, temp_buf, sector_size);


    LOG_INF("Contents of read out (800 bytes):");
    for (int i = 0; i < 800 && i < sector_size; i++) {
        if (i % 40 == 0 && i != 0) {
            LOG_INF("");  
        }
        printk("%02X ", temp_buf[i]);
    }

    if (sector_size > 800) {
        LOG_INF("\n... (plus %d more bytes)", sector_size - 800);
    }
    return 0;

}



int test_nand_top_layer(const struct spi_dt_spec *spidev_dt){
    LOG_INF("Starting tests top layer");

    if(test1_setup_erase_deinit_top_layer(spidev_dt) != 0){
        LOG_ERR("Failed first test top layer above DHARA");
        return -1;
    }

    if(test_struct_handling(spidev_dt) != 0){
        LOG_ERR("Failed to write to random secor");
        return -1;
    }


    if(test2_writing_tests_top_layer(spidev_dt) != 0){
        LOG_ERR("Failed second test top layer above DHARA");
        return -1;
    }

    return 0;
}
