
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/param.h>

#include <stdlib.h>
#include <string.h>
#include <zephyr/device.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <assert.h>

#include    "test_spi_nand_top_layer.h"
#include    "spi_nand_oper_tests.h"
#include    "nand_top_layer.h"





LOG_MODULE_REGISTER(test_spi_nand_top_layer, CONFIG_LOG_DEFAULT_LEVEL);


#define PATTERN_SEED    0x12345678

//Initialize the SPI device, TODO remove, since in the main we do this


//put the spi_handle into the spi_nand_flash_device_t struct and initialize the device
static void setup_nand_flash(spi_nand_flash_device_t **out_handle, const struct spi_dt_spec *spi_handle)
{

    spi_nand_flash_config_t nand_flash_config = {
        .spi_dev = spi_handle,
    };

    spi_nand_flash_device_t *device_handle = NULL;

    int ret = spi_nand_flash_init_device(&nand_flash_config, &device_handle);//TODO correctly handled? &
    if(ret != 0){
        LOG_ERR("Initialization of device on top layer, error: %d", ret);
    }else{
        LOG_INF("device on top layer initialized");
    }
    *out_handle = device_handle;
}



int test1_setup_erase_deinit_top_layer(const struct spi_dt_spec *spi)
{
    spi_nand_flash_device_t *nand_flash_device_handle = NULL;
    setup_nand_flash(&nand_flash_device_handle, spi);
    int err;
    err = spi_nand_erase_chip(nand_flash_device_handle);
    if(err != 0){
        LOG_ERR("Erase chip of device on top layer, error: %d", err);
        return -1;
    }


    //uint8_t status;
    // int ret = spi_nand_read_register(spi, REG_PROTECT, &status);//TODO REMOVE for debugging
    // ret = spi_nand_read_register(spi, REG_STATUS, &status);//TODO for debugging, properly erased, no error in registers found


    err = spi_nand_flash_deinit_device(nand_flash_device_handle);
    if(err != 0){
        LOG_ERR("Deinitialize device on top layer, error: %d", err);
        return -1;
    }
    LOG_INF("Test 1 DHARA top layer: setup, erase, deinit successful!");
    return 0;
    
}


/**
 * The check_buffer function is validating that each uint32_t sized segment of the buffer src matches a series 
 * of expected values generated by rand(), starting with a seed, to ensure the buffer's content integrity or 
 * correct data handling, particularly useful for debugging or testing memory operations where data consistency is crucial.
*/

static int check_buffer(uint32_t seed, const uint8_t *src, size_t count)
{
    int ret = 0;
    srand(seed);
    for (size_t i = 0; i < count; ++i) {
        uint8_t val = src[i];
        uint8_t expected = rand() & 0xFF; 
        if (val != expected) {
            if(i == 600){
            LOG_ERR("Mismatch at index %zu: expected 0x%02X, got 0x%02X", i, expected, val);
            }ret = -1;
        }
    }
    return ret;
}

static void fill_buffer(uint32_t seed, uint8_t *dst, size_t count){
    srand(seed);
    for (size_t i = 0; i < count; ++i) {
        dst[i] = rand() & 0xFF;  
        //LOG_INF("Index %zu: 0x%02X", i, dst[i]);
    }
}

static uint8_t pattern_buf[2048];
static uint8_t temp_buf[2048];

static int do_single_write_test(spi_nand_flash_device_t *flash, uint32_t start_sec, uint16_t sec_count)
{
    
    uint16_t sector_size, sector_num;
    memset((void *)pattern_buf, 0x00, sizeof(pattern_buf));
    memset((void *)temp_buf, 0x00, sizeof(temp_buf));

    int ret = spi_nand_flash_get_capacity(flash, &sector_num);
    if(ret != 0){
        LOG_ERR("Unable to retrieve flash capacity, error: %d", ret);
        return -1;
    }

    ret = spi_nand_flash_get_sector_size(flash, &sector_size);
    if(ret != 0){
        LOG_ERR("Unable to get sector size, error: %d", ret);
        return -1;
    }

    if ((start_sec + sec_count) > sector_num) {
        LOG_ERR("Sector range exceeds flash size.");
        return -1;
    }


    //fill the buffer with random indices
    fill_buffer(PATTERN_SEED, pattern_buf, sector_size);//we store every 4 byte address 4 bytes//(uint8_t*) pattern_buf??















    for (int i = start_sec; i < sec_count; i++) {
        uint8_t status;

        // LOG_INF("Contents of pattern_buf:"); //==> showed that it is always properly filled, TODO remove
        // for (int i = 0; i < sector_size; i++) {
        //     if (i % 40 == 0 && i != 0) {
        //         LOG_INF("");  // Print a new line every 40 bytes, but not before the first byte
        //     }
        //     printk("%02X ", pattern_buf[i]);
        // }
        //LOG_INF("");  // Ensure we end with a newline after the loop


        // ret = spi_nand_read_register(flash->config.spi_dev, REG_PROTECT, &status);//TODO REMOVE for debugging
        // ret = spi_nand_read_register(flash->config.spi_dev, REG_STATUS, &status);//TODO for debugging, properly erased
        //write buffer into sector
        if(spi_nand_flash_write_sector(flash, pattern_buf, i) != 0){
            LOG_ERR("Failed to write sector at index %d", i);
            return -1;
        }
        // ret = spi_nand_read_register(flash->config.spi_dev, REG_PROTECT, &status);//TODO REMOVE for debugging
        // ret = spi_nand_read_register(flash->config.spi_dev, REG_STATUS, &status);//TODO for debugging, properly erased, ECC bit error was detected
        
        //read sector into buffer
        if(spi_nand_flash_read_sector(flash, temp_buf, i) != 0){
            LOG_ERR("Failed to read sector at index %d", i);
            return -1;
        }
        ret = spi_nand_read_register(flash->config.spi_dev, REG_PROTECT, &status);//TODO REMOVE for debugging
        ret = spi_nand_read_register(flash->config.spi_dev, REG_STATUS, &status);//TODO for debugging, properly erased, no error in registers found
        
        //check if written random numbers are the same as read out ones
        check_buffer(PATTERN_SEED, temp_buf, sector_size);//TODO figure out how to address the entire page


        LOG_INF("Contents of temp_buf after reading:");
        for (int i = 0; i < sector_size; i++) {
            if (i % 40 == 0 && i != 0) {
                LOG_INF("");  // Print a new line every 40 bytes, but not before the first byte
            }
            printk("%02X ", temp_buf[i]);
        }
    }
    LOG_INF("\n\n\n");
    return 0;
}

int test2_writing_tests_top_layer(const struct spi_dt_spec *spi)
{
    
    // uint16_t sector_num, sector_size;
    spi_nand_flash_device_t *nand_flash_device_handle;
    setup_nand_flash(&nand_flash_device_handle, spi);

    // if(spi_nand_flash_get_capacity(nand_flash_device_handle, &sector_num) != 0){
    //     LOG_ERR("Unable to retrieve flash capacity");
    //     return -1;
    // }
    // if(spi_nand_flash_get_sector_size(nand_flash_device_handle, &sector_size) != 0){
    //     LOG_ERR("Unable to get sector size");
    //     return -1;
    // }
    // printf("Number of sectors: %d, Sector size: %d\n", sector_num, sector_size);

    LOG_INF("Test2, Setup complete");
    
    if(do_single_write_test(nand_flash_device_handle, 1, 16)!= 0){
        LOG_ERR("fails first single write test");
    }else{
        LOG_INF("single write read test 1 successful");
    }

    // if (do_single_write_test(nand_flash_device_handle, 16, 32) != 0) {
    //     LOG_ERR("Failed second single write test");
    // }else{
    //     LOG_INF("single write read test 2 successful");
    // }

    // if (do_single_write_test(nand_flash_device_handle, 32, 64) != 0) {
    //     LOG_ERR("Failed third single write test");
    // }else{
    //     LOG_INF("single write read test 3 successful");
    // }

    // if (do_single_write_test(nand_flash_device_handle, 64, 128) != 0) {
    //     LOG_ERR("Failed fourth single write test");
    // }

    // if (do_single_write_test(nand_flash_device_handle, sector_num / 2, 32) != 0) {
    //     LOG_ERR("Failed fifth single write test at middle of the flash");
    // }

    // if (do_single_write_test(nand_flash_device_handle, sector_num / 2, 256) != 0) {
    //     LOG_ERR("Failed sixth single write test at middle with larger span");
    // }

    // if (do_single_write_test(nand_flash_device_handle, sector_num - 20, 16) != 0) {
    //     LOG_ERR("Failed last single write test near the end of the flash");
    // }

    if(spi_nand_flash_deinit_device(nand_flash_device_handle) != 0){
        LOG_ERR("Deinitialize device on top layer");
        return -1;
    }
    return 0;
}

static int wait_and_chill(const struct spi_dt_spec *dev){
    uint8_t status;
    int ret = 0;
    while (true) {
        ret = spi_nand_read_register(dev, REG_STATUS, &status);
        if (ret != 0) {
            LOG_ERR("Error reading NAND status register while waiting");
            ret = -1;
        }

        if ((status & STAT_BUSY) == 0) {
            break;
        }
        k_sleep(K_MSEC(1)); // Sleep for 1 millisecond instead of using vTaskDelay  
    }
    return ret;
}


int test_struct_handling(const struct spi_dt_spec *spi){
    
    spi_nand_flash_device_t *flash;
    setup_nand_flash(&flash, spi);

    uint16_t sector_size, sector_num;
    uint32_t page = 0x00;
    memset((void *)pattern_buf, 0x00, sizeof(pattern_buf));
    memset((void *)temp_buf, 0x00, sizeof(temp_buf));

    int ret = spi_nand_flash_get_capacity(flash, &sector_num);
    if(ret != 0){
        LOG_ERR("Unable to retrieve flash capacity, error: %d", ret);
        return -1;
    }

    ret = spi_nand_flash_get_sector_size(flash, &sector_size);
    if(ret != 0){
        LOG_ERR("Unable to get sector size, error: %d", ret);
        return -1;
    }

    

    LOG_INF("Test 3: testing SPI NAND sector write and read register");
    
    //PREPARATION:

    //we assume a sector size of 2048 (smaller than page size of 2175)
    


    fill_buffer(PATTERN_SEED, pattern_buf, sector_size);//we store every 4 byte address 4 bytes//(uint8_t*) pattern_buf??


    // if (!device_is_ready(flash -> config.spi_dev->bus)) {
    //     LOG_ERR("Test 7: Device not ready");
    //     return -1;
    // }



    //////////////////////////////////////          WRITING             //////////////////////////////////////////////

    // uint16_t column_address = 0;//starting point to read from in page in cache
    // ret = spi_nand_read_page(flash -> config.spi_dev, page); 
    // if (ret != 0) {
    //     LOG_ERR("Test 7: Failed to read page %u, error: %d", page, ret);
    //     return -1;
    // }

    // ret = spi_nand_write_enable(flash -> config.spi_dev);
    // if (ret != 0) {
    //     LOG_ERR("Test 7: Failed to enable write, error: %d", ret);
    //     return -1;
    // }

    
    
    // //We just overwrite existing data in NAND array
    // //load data into cache
    // if(spi_nand_program_load(flash -> config.spi_dev, pattern_buf, column_address, sector_size) == 0){
    //     if(spi_nand_program_execute(flash -> config.spi_dev, page) != 0){
    //         LOG_ERR("Test7: Failed to write sector at index %d", 1);
    //         return -1;
    //     }
    // }

    //writing was checked and works
    if(spi_nand_flash_write_sector(flash, pattern_buf, 2) != 0){
        LOG_ERR("Failed to write sector at index %d", 1);
        return -1;
    }
    

////////////////////////////////////////        AFTER WRITING             ///////////////////////////////////////////////////////////////

    //check and wait if successful
    ret = wait_and_chill(flash -> config.spi_dev);
    if (ret != 0) {
        return -1;
    }

    if(spi_nand_flash_read_sector(flash, temp_buf, 2) != 0){
            LOG_ERR("Failed to read sector at index %d", 1);
            return -1;
        }



    


    // //read sector into buffer
    // // Read from the NAND array the block 0, page 0 everything 
    // ret = spi_nand_read_page(flash -> config.spi_dev, page); 
    // if (ret != 0) {
    //     LOG_ERR("Test 7: Failed to read page %u, error: %d", page, ret);
    //     return -1;
    // }
 
    // ret = wait_and_chill(flash -> config.spi_dev);
    // if (ret != 0) {
    //     return -1;
    // }
    // //read from cache
    // ret = spi_nand_read(flash -> config.spi_dev, temp_buf, 0, sector_size);
    // if (ret != 0) {
    //     LOG_ERR("Test 7: Failed to read , err: %d", ret);
    //     return -1; 
    // }


    //check if written random numbers are the same as read out ones
    ret = check_buffer(PATTERN_SEED, temp_buf, sector_size);//TODO figure out how to address the entire page

    if(ret == 0){
        LOG_INF("TEST 3: PASSED!!!");
    }


    // Log the first 100 bytes of temp_buf as hexadecimal values
    LOG_INF("Contents of temp_buf (800 bytes):");
    for (int i = 0; i < 800 && i < sector_size; i++) {
        if (i % 40 == 0 && i != 0) {
            LOG_INF("");  
        }
        printk("%02X ", temp_buf[i]);  // Using printk for continuous output on the same line
    }

    if (sector_size > 800) {
        LOG_INF("\n... (plus %d more bytes)", sector_size - 800);
    }
    return 0;

}


//////////////////////////////////     NEW TESTS EXTERNAL        /////////////
static int unprotect_chip(const struct spi_dt_spec *dev)
{
    uint8_t status;
    int ret = spi_nand_read_register(dev, REG_PROTECT, &status);
    if (ret != 0) {
        LOG_ERR("Failed to read register: %d", ret);
        return ret;
    }

    if (status != 0x00) {
        ret = spi_nand_write_register(dev, REG_PROTECT, 0);
    }
    if (ret != 0) {
        LOG_ERR("Failed to remove protection bit with error code: %d", ret);
        return -1;
    }

    return 0;
}


// private variables
static struct dhara_map map;
uint8_t page_buffer[2048];
static struct dhara_nand nand = {
    .log2_page_size = 11,
    .log2_ppb = 6,
    .num_blocks = 4096,
};


static int test_external(const struct spi_dt_spec *spi){
    memset((void *)pattern_buf, 0x00, sizeof(pattern_buf));
    memset((void *)temp_buf, 0x00, sizeof(temp_buf));
    fill_buffer(PATTERN_SEED, pattern_buf, 2048);

    int ret = spi_nand_erase_block(spi, 0);
    if (ret != 0) {
        LOG_ERR("Failed to erase block");
    }

    

    // spi_nand_flash_device_t *flash;
    // setup_nand_flash(&flash, spi);

    dhara_map_init(&map, &nand, page_buffer, 4);
    dhara_map_clear(&map);
    dhara_error_t err = DHARA_E_NONE;
    ret = dhara_map_resume(&map, &err);
    if (ret == -1){
        LOG_INF("Error while resuming dhara map, nothing there to resume");
    }

    unprotect_chip(spi);

    LOG_INF("Starting to write");
    if(dhara_map_write(&map, 2, pattern_buf, &err) != 0){
        LOG_ERR("Failed to write sector at index %d", 1);
        return -1;
    }

    //check and wait if successful
    ret = wait_and_chill(spi);
    if (ret != 0) {
        return -1;
    }
    LOG_INF("Starting to read");

    if(dhara_map_read(&map, 2, temp_buf, &err) != 0){
        LOG_ERR("Failed to read sector at index %d", 1);
        return -1;
    }

    LOG_INF("Contents of temp_buf (800 bytes):");
    for (int i = 0; i < 2048; i++) {
        if (i % 40 == 0 && i != 0) {
            LOG_INF("");  
        }
        printk("%02X ", temp_buf[i]);  // Using printk for continuous output on the same line
    }

    // if (2048 > 800) {
    //     LOG_INF("\n... (plus %d more bytes)", 2048 - 800);
    // }
    LOG_INF("End of external test");
    return 0;

}

//////////////////////////////////     NEW TESTS EXTERNAL        /////////////




int test_nand_top_layer(const struct spi_dt_spec *spidev_dt){
    LOG_INF("Starting tests top layer");
    // if(test1_setup_erase_deinit_top_layer(spidev_dt) != 0){
    //     LOG_ERR("Failed first test top layer above DHARA");
    //     return -1;
    // }

    // test_struct_handling(spidev_dt);


    // if(test2_writing_tests_top_layer(spidev_dt) != 0){
    //     LOG_ERR("Failed second test top layer above DHARA");
    //     return -1;
    // }

    test_external(spidev_dt);
    //LOG_INF("Successful tests DHARA top layer");
    return 0;
}
